---
title: "Part 2: Analysing Time Series Data"
subtitle: "Pharmacy Australia Centre of Excellence x Library R workshop"
slug: "analysing"
author: "Catherine Kim"
date: "2022-01-27"
categories: ["R"]
tags: [""]
output:
  blogdown::html_page:
    df_print: tibble
    toc: true
    number_sections: TRUE
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, warnings = FALSE)
```

**Catherine Kim, PhD**

Technology Trainer, The University of Queensland Library

## Prerequisites 

This R workshop assumes basic knowledge of R including:

* Installing and loading packages
* How to read in data
    + read.csv
    + read_csv
    + and similar
* Creating objects in R

We are happy to have any and all questions though!

## What are we going to learn?

In this hands-on session...

## Load packages

```{r packages, warning=FALSE, message = FALSE}
library(tidyverse)
library(lubridate) # work with dates
library(readxl) # read excel files

library(zoo)
library(forecast)
library(tseries) # test for stationarity
```

## About the data

...

## Read in the excel sheets

For this section, we will go the process of analysing time series for one site. 

Let's read in the first just the first site sheet from the excel file.

```{r}
s1335 <- read_excel("Data workshop.xlsx", sheet = 3) %>% 
   rename(Site = 1, Date = 3, mg_per_day = 7) %>% 
   mutate(Site = factor(Site), # change columns to factor
                   Year = as.factor(Year),
                   Month = as.factor(Month)) 
```

### Visualize the data for one site

```{r}
ggplot(s1335,
        aes(Date, mg_per_day, color = Site)) +
   geom_point()
```

Count the number of samples per month.

```{r}
s1335 %>% 
   group_by(Year, Month) %>% 
   summarize(count = n()) %>% 
   arrange(-count) # arrange by count column in descending order
```

The maximum number of samples we have per month is 7. Probably not enough to do any meaningful analysis for a daily trend. Let's average samples by month. There also can be no data gaps for a time series (ts) data class.

```{r}
ave_s1335 <- s1335 %>% 
   group_by(Year, Month, Site, Date) %>% 
   summarize(mg_per_day = mean(mg_per_day),
             SD = sd(mg_per_day))
```

Alternatively, can graphically summarize the distribution of dates using the `hist()` (`hist.Date()`) function. 

```{r}
hist(as.Date(s1335$Date), # change POSIXct to Date object
     breaks = "months", 
     freq = TRUE,
     xlab = "", # remove label so doesn't overlap with date labels,
     format = "%b %Y", # format the date label, mon year
     las = 2)
```

Let's convert our data into a time series. Times series data must be sampled at equispaced points in time.

There are several different time series object that have different functionalalities such as working with irregularly spaced time series. See this [resource](https://faculty.washington.edu/ezivot/econ424/Working%20with%20Time%20Series%20Data%20in%20R.pdf).

```{r}
ts_1335 <- ts(ave_s1335$mg_per_day, frequency = 12,
                 start = c(1991, 11), end = c(2000, 9))

class(ts_1335) # check the object class
ts_1335 # see the data


```

## Create a irregularly spaced time series using the zoo (Zeileis ordered observations) package

The `zoo` class is a flexible time series data with an ordered time index. The data is stored in a matrix with vector date information attached. Can be regularly or irregularly spaced.

```{r}
library(zoo)
z_1335 <- zoo(s1335$mg_per_day, order.by = s1335$Date)

head(z_1335)
```

## Decomposition

Decomposition separates out a times series $Y_{t}$ into a seasonal $S_{t}$, trend $T_{t}$, and error/residual $E_{t}$ components.

These elements can be *additive* when the seasonal component is relatively constant over time.

$$Y_{t} = S_{t} + T_{t} + E_{t}$$

Or *multiplicative* when seasonal effects tend to increase as the trend increases.

$$Y_{t} = S_{t} * T_{t} * E_{t}$$

The `decompose()` function uses a moving average (MA) approach to filter the data. The *window* or period over which you after is based on the frequency of the data. For example, monthly data can be averaged across a 12 month period.

```{r}
library(xts)
xts_1335 <- as.xts(x = ave_s1335$mg_per_day, order.by = ave_s1335$Date)

k2 <- rollmean(xts_1335, k = 2)
k4 <- rollmean(xts_1335, k = 4)
k8 <- rollmean(xts_1335, k = 8)
k16 <- rollmean(xts_1335, k = 16)
k32 <- rollmean(xts_1335, k = 32)

kALL <- merge.xts(xts_1335, k2, k4, k8, k16, k32)
head(kALL)

plot.xts(kALL, multi.panel = TRUE)
```

Let's use the  use the `stats::decompose()` function for an additive model:

```{r}
decomp_1335 <- decompose(ts_1335, type = "additive") # additive is the default
plot(decomp_1335)
```

In the top 'observed' plot there does not appear to be a clear case of seasonality increasing over time so the additive model should be fine. There is a huge peak in the trend in 1995 which decreases until around 1998 before increasing again.

## Remove seasonality components using the forecast package.

```{r}
stl_1335 <- stl(ts_1335, s.window = "periodic") # deompose into seasonal, trend, and irregular components
head(stl_1335$time.series)
```

The seasonal and reminder/irregular components are small compared to the trend component.

Let's seasonally adjust the data and plot the raw data and adjusted data.

```{r}
sa_1335 <- seasadj(stl_1335) # seasonally adjusted data

par(mfrow = c(2,1))
plot(ts_1335) #, type = "1")
plot(sa_1335)
```

These two plots are pretty much the same. There does not seem to be a large seasonality component in the data.

It can also be visualised using on the same plot to highlight the small effect of seasonality.

```{r}
s1335_deseason <- ts_1335 - decomp_1335$seasonal # manually adjust for seasonality

deseason <- ts.intersect(ts_1335, s1335_deseason) # bind the two time series

plot.ts(deseason, 
        plot.type = "single",
        col = c("red", "blue"),
        main = "Original (red) and Seasonally Adjusted Series (blue)")
```

Plot the time series against the seasons in separate years.

```{r}
par(mfrow = c(1,1))
seasonplot(sa_1335, 12, col=rainbow(12), year.labels=TRUE, main="Seasonal plot: Site 1335")
```

The lines do not really follow the same pattern throughout the year - again, not a big seasonality component.

## Stationarity

The **residual** part of the model should be **random** where the model explained most significant patterns or *signal* in the time series leaving out the *noise*.

[This article](http://r-statistics.co/Time-Series-Analysis-With-R.html) states that the following conditions must be met:

1. The mean value of time-series is constant over time, which implies, the trend component is nullified.
2. The variance does not increase over time.
3. Seasonality effect is minimal.

There are a few tests for stationarity with the `tseries` package: Augmented Dickery-Fuller and KPSS. See this [section](https://atsa-es.github.io/atsa-labs/sec-boxjenkins-aug-dickey-fuller.html). 

```{r}
adf.test(ts_1335) # p-value < 0.05 indicates the TS is stationary
kpss.test(ts_1335, null = "Trend") # null hypothesis is that the ts is level/trend stationary, so do not want to reject the null, p > 0.05
# 
```

The tests indicate that the time series is not stationary. How do you make a non-stationary time series stationary?

## Differencing

One common way is to *difference* a time series - subtract each point in the series from the previous point.

Using the `forecast` package, we can do *seasonal differencing* and *regular differencing*.

```{r}
nsdiffs(ts_1335, type = "trend") # seasonal differencing
ndiffs(ts_1335, type = "trend") # type 'level' deterministic component is default

stationaryTS <- diff(ts_1335, differences= 1)

diffed <- ts.intersect(ts_1335, stationaryTS) # bind the two time series

plot.ts(diffed, 
        plot.type = "single",
        col = c("red", "blue"),
        main = "Original (red) and Differenced Series (blue)")
```

Let's check the differenced time series with the same stationarity tests: 

```{r}
adf.test(stationaryTS) 
kpss.test(stationaryTS, null = "Trend")
```

The both tests now indicate the differenced time series is now stationary.

## Autocorrelation

### Autocorrelation plots

Plot the **autocorrelation function** (ACF) correlogram for the time series. There are *k* lags on the x-axis and the unit of lag is sampling interval (month here). Lag 0 is always the theoretical maximum of 1 and helps to compare other lags. 

The cutest explanation of ACF by Dr Allison Horst:

![acf art by Allison Horst](acf_1.jpg)

```{r}
acf(s1335$mg_per_day)
```

You can used the ACF to estimate the number of moving average (MA) coefficients in the model. Here, there are 3 to 4 significant autocorrelation. The lags crossing the dotted blue line are statistically significant.

The **partial autocorrelation function** can also be plotted. The partial correlation is the left over correlation at lag *k* between all data points that are *k* steps apart accounting for the correlation with the data between *k* steps.

```{r}
pacf(s1335$mg_per_day)
```

Practically, this can help us identify the number of autoregression (AR) coefficients in an autoregression integrated moving average (ARIMA) model. The above plot shows *k* = 3 so the initial ARIMA model will have three AR coefficients (AR(3)). The model will still require fitting and checking.

### Autocorrelation test

There is also the `base::Box.test()` function that can be used to test for autocorrelation:

```{r}
Box.test(ts_1335)
```

The p-value is significant which means the data contains significant autocorrelations.

## Autoregressive model

Autoregressive (AR) models can simulate *stochastic* trends by regressing the time series on its past values. Order selection is done by Arkaike Information Criterion (AIC) and method chosen here is maximum likelihood estimation (mle).

```{r}
ar_1335 <- ar(ts_1335, method = "mle")

mean(ts_1335)

ar_1335$order
ar_1335$ar
acf(ar_1335$res[-(1:ar_1335$order)], lag = 50) 
```

The correlogram of residuals has a few marinally significant lags (around 15 and between 30-40). The AR(4) model is a relatively good fit for the time series.

## Regression

*Deterministic* trends and seasonal variation can be modelled using regression.

Linear models are non-stationary for time series data, thus a non-stationary time series must be differenced.

```{r}
chem <- window(ts_1335, start = 1991)
head(chem)

chem.lm <- lm(chem ~ time(chem))
coef(chem.lm)

confint(chem.lm)
acf(resid(chem.lm))
```

## gls

```{r}
library(nlme)
chem.gls <- gls(chem ~ time(chem), cor = corAR1(0.7))
coef(chem.gls)
confint(chem.gls)
acf(resid(chem.gls))
```

## seasonal component

```{r}
Seas <- cycle(chem)
Time <- time(chem)
chem.lm <- lm(chem ~ 0 + Time + factor(Seas))
coef(chem.lm)
acf(resid(chem.lm))
```

## ARIMA

```{r}
par(mfrow = c(2,1))
plot(ts_1335)
plot(diff(ts_1335))
```

```{r}
AIC (arima(ts_1335, order = c(1,1,0),
seas = list(order = c(1,0,0), 12)))

chem.arima <-  (arima(ts_1335, order = c(0,1,1),
seas = list(order = c(0,0,1), 12)))

acf(resid(chem.arima), lag = 50)
```

## Resources 

Resources used to compile this session included:
* [Ch 14 Time Series Analysis](https://rc2e.com/timeseriesanalysis) in R Cookbook, 2nd edition, by JD Long and Paul Teetor. Copyright 2019 JD Long and Paul Teetor, 978-1-492-04068-2
* [Time Series Analysis with R](https://nicolarighetti.github.io/Time-Series-Analysis-With-R/) by Nicola Righetti
